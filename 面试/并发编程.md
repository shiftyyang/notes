# 0 - 并发编程体系

![image-20220531222150722](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531222150722.png)

# 1 - 理论基础

### 为什么需要多线程

平衡 cpu、内存、IO 速度差异，合理利用 CPU 性能。



### 并发问题根源：并发三要素

##### 1. 可见性

> cpu 缓存导致

一个线程对共享变量的修改，另一个线程能立即看到。

##### 2. 原子性

> 时分复用引起

一个或多个操作，要不全部执行，要不就不执行。

##### 3. 有序性

> 重排序引起

程序执行的顺序按照代码执行的顺序执行。

* 编译器优化的重排序
* 指令级并行的重排序
* 内存系统的重排序

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531222705423.png" alt="image-20220531222705423" style="zoom: 50%;" />



### Java 怎么解决并发问题：JMM（Java 内存模型）

> JAVA 内存模型规范了 JVM 如何按需禁用缓存和编译优化的方法：
>
> * Volatile	Synchronized	final
> * Happens-Before 原则

分别针对并发三要素的解决方案：

##### 1. 可见性

Volatile 保证可见性。

> 保证修改的值立刻会被更新到主存

Synchronized、Lock 保证可见性。

> 同一时刻只有一个线程能执行，释放锁刷到主存。

##### 2. 原子性

Synchronized、Lock 实现原子性。

> Java 内存模型只保证简单的赋值和读取操作为原子操作
>
> 下图只有语句 1 是原子操作：

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531223354876.png" alt="image-20220531223354876" style="zoom:50%;" />

##### 3. 有序性

Synchronized、Lock 保证有序性。

Volatile 保证一定的有序性。

JMM 通过 Happens-Before 规则保证有序性。



### Happens-Before 规则

##### 1. 单一线程原则

> 同一线程内，前面操作对后面可见。

##### 2. 管程锁定规则

>  一个 unlock 对于后面的 lock 可见。

##### 3. Volatile 变量规则

> 对一个 Volatile 变量写操作对于后续 Volatile 读操作可见。

##### 4. 线程启动规则

> start() 方法调用先发生于此线程的每一个动作。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531224137734.png" alt="image-20220531224137734" style="zoom:50%;" />

##### 5. 线程加入规则

> 对象结束先发生于 join() 方法返回。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531224155229.png" alt="image-20220531224155229" style="zoom:50%;" />

##### 6. 线程中断规则

> 对线程 interrupt() 方法的调用先发生于被中断线程的代码。

##### 7. 对象终结规则

> 一个对象的初始化完成，先发生于他的 finalize() 方法的开始。

##### 8. 传递性规则

> A -> B, B -> C, 则 A -> C



### 线程安全：强弱之分

**不可变 > 绝对线程安全 > 相对线程安全 > 线程兼容 > 线程对立**

##### 1. 不可变

* final

* String

* enum

* Number

  > Long	Double	BigInteger	BigDecimal

* 集合类型

  > Collections.unModifiableMap(map)

##### 2. 绝对线程安全

​	不管线程运行时环境如何，调用者都不需要额外的同步措施

##### 3. 线程相对安全

​	保证对这个对象单独的操作都是线程安全的，特定顺序的连续操作不能保证安全。

> Vector、HashTable、Collections 的 SynchronizedCollection() 方法包装的集合等。
>
> 例如：
>
> ​	一个线程删除了 Vector 的一个元素，另一个线程试图访问一个已经被删除的元素，会抛出 ArrayIndexOutOfBoundsException

##### 4. 线程兼容

可以使用正确手段保证对象在并发环境中，可以安全的使用。ArrayList、HashMap 等。

##### 5. 线程对立

无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

> Java 语言很少。



### 线程安全的实现方法

##### 1. 互斥同步

Synchronized 和 ReentrantLock

> 互斥问题：线程阻塞和唤醒带来的性能消耗，又叫阻塞同步。
>
> 无论是否有竞态条件，都会加锁叫悲观锁。

##### 2. 非阻塞同步

1）CAS

> 乐观并发策略：先操作，如果没有竞争共享锁，则成功。否则采取补偿措施。
>
> compare-and-swap（比较并交换），三个操作数：内存地址 V，旧预期值 A 和新值 B，当 V = A 时，才会将 V 更新为 B。

2）AtomicInteger

> compareAndSet() 和 getAndIncrement() 方法都使用了 unsafe() 类的 CAS 操作。

3）ABA

>  一个变量初始值为 A，修改为 B，改回 A，CAS 操作误以为它从来没有更新过。JUC 包提供了一个带有标记的原子引用类 AtomicStampedReference ，通过控制版本号来保证 CAS 的正确性 。

##### 3. 无同步方案

如果不涉及到共享数据，则无需tongue

1）栈封闭性

> 多个变量访问同一个方法局部变量，局部变量存在虚拟机栈中，属于线程私有。

2）线程本地存储

> ThreadLocal

3）可重入代码

> 不依赖存储在堆上的数据和公共系统资源





