

# 0 - 并发编程体系

![image-20220531222150722](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531222150722.png)

# 1 - 理论基础

### 为什么需要多线程

平衡 cpu、内存、IO 速度差异，合理利用 CPU 性能。



### 并发问题根源：并发三要素

##### 1. 可见性

> cpu 缓存导致

一个线程对共享变量的修改，另一个线程能立即看到。

##### 2. 原子性

> 时分复用引起

一个或多个操作，要不全部执行，要不就不执行。

##### 3. 有序性

> 重排序引起

程序执行的顺序按照代码执行的顺序执行。

* 编译器优化的重排序
* 指令级并行的重排序
* 内存系统的重排序

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531222705423.png" alt="image-20220531222705423" style="zoom: 50%;" />



### Java 怎么解决并发问题：JMM（Java 内存模型）

> JAVA 内存模型规范了 JVM 如何按需 **禁用缓存和编译优化** 的方法：
>
> * Volatile	Synchronized	final
> * Happens-Before 原则

分别针对并发三要素的解决方案：

##### 1. 可见性

Volatile 保证可见性。

> 保证修改的值立刻会被更新到主存

Synchronized、Lock 保证可见性。

> 同一时刻只有一个线程能执行，释放锁刷到主存。

##### 2. 原子性

Synchronized、Lock 实现原子性。

> Java 内存模型只保证简单的赋值和读取操作为原子操作
>
> 下图只有语句 1 是原子操作：

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531223354876.png" alt="image-20220531223354876" style="zoom:50%;" />

##### 3. 有序性

Synchronized、Lock 保证有序性。

Volatile 保证一定的有序性。

JMM 通过 Happens-Before 规则保证有序性。



### Happens-Before 规则

##### 1. 单一线程原则

> 同一线程内，前面操作对后面可见。

##### 2. 管程锁定规则

>  一个 unlock 对于后面的 lock 可见。

##### 3. Volatile 变量规则

> 对一个 Volatile 变量写操作对于后续 Volatile 读操作可见。

##### 4. 线程启动规则

> start() 方法调用先发生于此线程的每一个动作。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531224137734.png" alt="image-20220531224137734" style="zoom:50%;" />

##### 5. 线程加入规则

> 对象结束先发生于 join() 方法返回。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220531224155229.png" alt="image-20220531224155229" style="zoom:50%;" />

##### 6. 线程中断规则

> 对线程 interrupt() 方法的调用先发生于被中断线程的代码。

##### 7. 对象终结规则

> 一个对象的初始化完成，先发生于他的 finalize() 方法的开始。

##### 8. 传递性规则

> A -> B, B -> C, 则 A -> C



### 线程安全：强弱之分

**不可变 > 绝对线程安全 > 相对线程安全 > 线程兼容 > 线程对立**

##### 1. 不可变

* final

* String

* enum

* Number

  > Long	Double	BigInteger	BigDecimal

* 集合类型

  > Collections.unModifiableMap(map)

##### 2. 绝对线程安全

​	不管线程运行时环境如何，调用者都不需要额外的同步措施

##### 3. 线程相对安全

​	保证对这个对象单独的操作都是线程安全的，特定顺序的连续操作不能保证安全。

> Vector、HashTable、Collections 的 SynchronizedCollection() 方法包装的集合等。
>
> 例如：
>
> ​	一个线程删除了 Vector 的一个元素，另一个线程试图访问一个已经被删除的元素，会抛出 ArrayIndexOutOfBoundsException

##### 4. 线程兼容

可以使用正确手段保证对象在并发环境中，可以安全的使用。ArrayList、HashMap 等。

##### 5. 线程对立

无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

> Java 语言很少。



### 线程安全的实现方法

##### 1. 互斥同步

Synchronized 和 ReentrantLock

> 互斥问题：线程阻塞和唤醒带来的性能消耗，又叫阻塞同步。
>
> 无论是否有竞态条件，都会加锁叫悲观锁。

##### 2. 非阻塞同步

1）CAS

> 乐观并发策略：先操作，如果没有竞争共享锁，则成功。否则采取补偿措施。
>
> compare-and-swap（比较并交换），三个操作数：内存地址 V，旧预期值 A 和新值 B，当 V = A 时，才会将 V 更新为 B。

2）AtomicInteger

> compareAndSet() 和 getAndIncrement() 方法都使用了 unsafe() 类的 CAS 操作。

3）ABA

>  一个变量初始值为 A，修改为 B，改回 A，CAS 操作误以为它从来没有更新过。JUC 包提供了一个带有标记的原子引用类 AtomicStampedReference ，通过控制版本号来保证 CAS 的正确性 。

##### 3. 无同步方案

如果不涉及到共享数据，则无需tongue

1）栈封闭性

> 多个变量访问同一个方法局部变量，局部变量存在虚拟机栈中，属于线程私有。

2）线程本地存储

> ThreadLocal

3）可重入代码

> 不依赖存储在堆上的数据和公共系统资源



# 2 - Java 线程基础

![image-20220606220043625](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220606220043625.png)

### 线程状态

##### 1. 新建

>创建后尚未启动

##### 2. 可运行

>正在运行或者等待 CPU 时间片（包含操作系统状态中的 Running 和 Ready）

##### 3. 阻塞

>等待获取一个排它锁

##### 4. 无限期等待

>知道其它线程显示唤起

##### 5.限期等待

>被系统唤醒

##### 6. 死亡

>完成任务结束或者异常结束



### 线程使用方式

* 实现 Runnable （只是一个线程任务）
* 实现 Callable （只是一个线程任务）
* 继承 Thread



### 基础线程机制
##### 1. Executor

> Executor 管理多个异步任务的执行，无需程序员显式的管理线程的生命周期

三种 Executor：

* CachedThreadPool：每个任务创建一个线程
* FixedThreadPool：所有任务只能使用固定大小的线程
* SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool



##### 2. Daemon

> 守护线程是程序运行时后台提供服务的线程。
>
> 所有非守护线程结束，程序结束，同时杀死所有守护线程。

main() 属于非守护线程。

thread.setDaemon(true) 设置守护线程。



##### 3. interrupted()

thread.interrup() 设置一个中断标记，可以中断 sleep() wait() await()

任务中可以调用 interrupt() ，判断是否返回 true，则标识中断。

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1); // 暂停1毫秒
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println("end");
    }
}

class MyThread extends Thread {
    public void run() {
        int n = 0;
        while (! isInterrupted()) {
            n ++;
            System.out.println(n + " hello!");
        }
    }
}
```



### Executor 的中断操作

shutdown() 等所有线程都执行完成后再关闭，shutdownNow() 相当于对每个线程都调用 interrupt() 方法。

只中断一个线程：

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220606224149266.png" alt="image-20220606224149266" style="zoom:50%;" />



#### 线程协作：join()

#### Object：wait()	notify()	notifyAll()	Synchronized 使用

#### lock.newCondition(): await()	signal()	signalAll()



# 3 - Synchronized 详解

## Synchronized 原理分析

### 1. 加锁释放锁的原理

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220606224740401.png" alt="image-20220606224740401" style="zoom:50%;" />

##### **Monitorenter 和 Monitorexit 指令**：

同一线程获取锁，让计数器 +1。释放锁，让计数器 -1。重入锁，累加。



### 2. 保证可见性原理

**JMM 内存模型和 Happens-Before 规则。**



### 3. Synchronized 和 Lock

##### Synchronized 缺陷：

1. 效率低：只有执行完成或异常才会释放锁。
2. 不灵活：加锁释放锁单一，每个锁只有一个单一对象。
3. 不能设置超时和中断。
4. 无法获取锁状态，Lock 可以获取状态。

##### Lock 解决相应问题：

> lock()	unlock()	tryLock()	tryLock(long, TimeUnit)

condition 和 lock 结合使用，更灵活。

Synchronized 不能中断，高并发下性能下降。

ReentrantLock 的 lockInterruptibly() 方法可以优先考虑响应中断，一个线程等待时间过长，可以中断自己，不会像 Synchronized 产生死锁。



##### Synchronized 使用注意事项

1. 锁对象不能为空，锁信息保存在对象头中；
2. 作用域不宜过大，影响执行速度；
3. 避免死锁；
4. 尽量使用 JUC 包中的类；
5. 是非公平锁。



## JVM 中锁优化

### 1. 优化概括

monitorenter 和 Monitorexit --> 依赖操作系统 mutex lock 来实现。

> 使用 mutex lock 需要将当前线程挂起，并从用户态切换到内核态执行，切换代价十分高昂。

**java 1.6 优化：**

##### 1. 锁粗化

> 减少不必要的 lock、unlock 操作，合并一个大范围的锁。

##### 2. 锁消除

> 逃逸分析，消除被其他线程共享数据的锁。

##### 3. 轻量级锁

> CAS 原子指令，存在锁竞争，则执行操作系统互斥锁。

##### 4. 偏向锁

> 无锁竞争下在锁获取过程中执行不必要的 CAS 原子指令。

##### 5. 适应性自旋

> 循环等待不断判断锁能否被成功获取。
>
> 优点：避免切换线程	 缺点：循环时间过久，占用处理器资源。
>
> 过程：CAS 失败，while 自旋等待，再次尝试一定次数没有成功，调用 monitor 相关 semaphore 进入阻塞状态。



### 2. 锁膨胀方向

##### 无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁



### 3. 锁的特性

##### 自旋锁和适应性自旋锁

自旋锁：固定次数，挂起。

适应性自旋：自旋时间不固定。

> 由 上一次自旋时间 和 锁拥有者状态 决定。
>
> 自旋等待刚刚成功获取过锁，持有锁的线程正在运行中，JVM 认为自旋获取锁可能性大，会增加自旋次数或等待时间。
>
> 某个锁很少自旋成功获取过锁，后续可能省略自旋过程。

**锁消除**

JVM 判断不存在逃逸代码，会进行锁消除

##### **锁粗化**

一连串同一个对象加锁，锁粗化将范围扩大。

##### 轻量级锁

 [轻量级锁.md](轻量级锁.md) 

##### 偏向锁

 [偏向锁.md](偏向锁.md) 



### 4. 锁优缺点对比

![6](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/6.png)



# 4 - volatile 详解

### Volatile 作用

#### 防止重排序

**双检锁**

> 实例化一个对象的流程分为三个步骤：
>
> - 分配内存空间
> - 初始化对象
> - 将内存空间的地址赋值给对应的引用
>
> 操作系统可能对指令进行重排序，步骤顺序有可能会改变：
>
> - 分配内存空间
> - 将内存空间的地址赋值给引用对象
> - 初始化对象
>
> 这样未初始化的对象引用暴露出来，可能会有不可预期的后果。

#### 实现可见性

导致可见性的主要原因：每个线程都有一个高速缓存区——线程工作内存。

volatile 保证数据可见性。

#### 保证原子性

只能保证单次读写具有原子性。

> 不能保证 i++ 的原子性，这是读写两次操作。



### Volatile 实现原理

#### 基于内存屏障实现：

> * 内存屏障，又叫内存栅栏，一个 cpu 指令
> * 通过插入特定的内存屏障，禁止编译器和处理器重排序，不管什么指令都不能和这条 Memory Barrier 指令重排序。

声明了 volatile 的变量进行写操作，JVM 向处理器发送一条 lock 前缀指令，将这个变量所在缓存行的数据写回系统内存。

**“嗅探”总线，更新。**

>  为了保证各个处理器的缓存是一致的，每个处理器通过嗅探总线上传播的数据检查自己的值是否过期，如果发现自己缓存行对应的内存地址被修改，则将缓存行设置成为无效，并且更新。



### Volatile 应用场景

> 使用 volatile 必备条件：
>
> 1. 对变量写操作不依赖当前值；
> 2. 该变量没有包含在具有其它变量的不变式中；
> 3. 只有状态真正独立于程序内其它内容时，才能使用 volatile。

#### 模式一：状态标志

使用一个 bool 状态标志，用于指示一个重要的一次性事件。例如完成初始化或请求停机。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/1.png" alt="1" style="zoom:50%;" />

#### 模式二：一次性安全发布

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/2.png" alt="2" style="zoom:50%;" />

#### 模式三：独立观察

定时任务隔几秒更新传感器值，其它线程可以读取到这个变量，随时看到最新的温度值。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/3.png" alt="3" style="zoom:50%;" />

#### 模式四：volatile bean 模式

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/4.png" alt="4" style="zoom:50%;" />

#### 模式五：开销较低的读写锁策略

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/5.png" alt="5" style="zoom:50%;" />

#### 模式六：双重检查锁



# 5 - final 详解

### final 基础使用

#### 修饰类

类不能被继承，方法和属性隐式 final



#### 修饰方法

1. private 方法是隐式 final
2. final 方法可以被重载
3. final 方法不可以被重写



#### 修饰参数

无法在方法中更改参数引用对象



#### 修饰变量

不是所有 final 值都是编译器常量，只有 k 值被初始化后无法被更改。

<img src="http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220608222511504.png" alt="image-20220608222511504" style="zoom:50%;" />

#### static final

只占据一段不能改变的存储空间，必须在定义的时候进行赋值。



#### final 域重排序规则

编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障，禁止处理器把 final 域写重排序到构造函数之外。





# 6 - JUC 类汇总

![java-thread-x-juc-overview-1](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-overview-1.png)



### Lock 框架和 Tools 类

#### 类结构

![java-thread-x-juc-overview-lock](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-overview-lock.png)

##### 接口：Condition

> await() 	signal()	signal() 休眠和唤醒线程。

##### 接口：Lock

> 提供比 Synchronized 更广泛的锁定操作，可以支持多个相关的 Condition 对象。

##### 接口：ReadWriteLock

> 维护一对相关的锁，一个用于只读，一个用于写入操作。

##### 抽象类：AbstractLongQueuedSynchronizer

> 当创建 64 位状态多级别锁和屏障同步器，此类很有用。

##### 核心抽象类（AQS)：AbstractQueuedSychronizer

> 实现依赖 FIFO 等待队列的阻塞锁和相关同步器（信号量、事件等）提供的一个框架。
>
> 设计目标：成为依靠单个原子值 int 表示状态的大部分同步器基础。

##### 锁常用类：LockSupport

> 创建锁、其它同步类基本线程同步阻塞原语。（类似于 Thread 中 suspend()、resume() ）
>
> LockSupport 中 park() unpark() ，不会遇到 Thread 的死锁问题。

##### 锁常用类：ReetrantLock

> 可重入同步互斥锁

##### 工具类：StampLock（票据锁）

> Java8 提供。
>
> 三种模式：读、写、乐观锁。
>
> 一个 stampLock 状态由版本和模式组成。获取锁返回一个票据 stamp，用相应的锁状态标识并控制访问，数字 0 表示没有写锁，可以被访问。读锁分为悲观锁和乐观锁。

##### 工具类：CountDownLatch

> 同步辅助类，在完成一组正在其它线程中执行的操作之前，它允许一个或多个线程一直等待。

##### 工具类：CyclicBarrier 

> 同步辅助类，允许一组线程相互等待，知道达到某个公共屏障点（common barrier point）。在一组固定大小的线程程序中，这些线程必须不停等待。

##### 工具类：Phaser

> 同步辅助类 Java7，实现 CountDownLatch 和 CyclicBarrier 类似的功能，支持对任务的动态调整，支持分层结构达到更高的吞吐量。

##### 工具类：Semaphore

> 计数信号量，维护一个许可集。
>
> 限制可访问某些资源的线程数目。（物理、逻辑）

##### 工具类：Exchanger

> 线程协作工具类，主要用于两个线程之间的数据交换。
>
> 提供一个同步点，在这个同步点，两个线程可以交换数据。两个线程通过 exchange() 方法交换数据：一个线程执行 exchange() 方法，会等待第二个线程也执行 exchange() 方法，两个线程到达同步点，就可以交换数据。



### Collections ：并发集合

![java-thread-x-juc-overview-2](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-overview-2.png)

#### Queue：

##### ArrayBlockingQueue

![image-20220621102543733](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102543733.png)

##### LinkedBlockingQueue

![image-20220621102601078](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102601078.png)

##### LinkedBlockingDeque

##### ConcurrentLinkedQueue

![image-20220621102706928](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102706928.png)

##### ConcurrentLinkedDeque

##### DelayQueue

![image-20220621102838877](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102838877.png)

##### PriorityBlockingQueue

![image-20220621102910815](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102910815.png)

##### SynchronousQueue

![image-20220621102928311](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621102928311.png)

##### LinkedTransferQueue

![image-20220621103101761](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621103101761.png)

#### List:

##### CopyOnWriteArrayList

![image-20220621103207859](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621103207859.png)

#### Set:

##### CopyOnWriteArraySet

![image-20220621103820065](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621103820065.png)

##### ConcurrentSkipListSet

![image-20220621104338760](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621104338760.png)

#### Map:

##### ConcurrentHashMap

![image-20220621104527286](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621104527286.png)

##### ConcurrentSkipListMap

![image-20220621104552368](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621104552368.png)



### Atomic：原子类

> 基本特性：多线程具有排他性。

##### 基础类型：AtomicBoolean，AtomicInteger，AtomicLong

![image-20220621105941113](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621105941113.png)

##### 数组：AtomicIntegerArray，AtomicLongArray，BooleanArray

![image-20220621110034256](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110034256.png)

##### 引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference

![image-20220621110134527](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110134527.png)

##### FieldUpdater：AtomicLongFiledUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater

![image-20220621110328801](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110328801.png)



### Executors：线程池

![](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-executors-1.png)

#### 接口：

#### Executor

![image-20220621110612267](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110612267.png)

#### ExecutorService

![image-20220621110636988](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110636988.png)

#### ScheduleExecutorService

![image-20220621110817031](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110817031.png)

#### AbstractExecutorService

![image-20220621110841290](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220621110841290.png)

#### FutureTask

![image-20220622105347414](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220622105347414.png)



#### 核心：

#### ThreadPoolExecutor

![image-20220622110302704](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220622110302704.png)

#### ScheduledThreadExecutor

![image-20220622110404868](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220622110404868.png)

#### Fork/Join 框架

![image-20220622110506215](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220622110506215.png)

#### 工具类：

#### Executors

![image-20220622110535744](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/image-20220622110535744.png)



# 7 - JUC 原子类

> **CAS	Unsafe	原子类**

## CAS

>两个值，新值和旧值，比较旧值有没有变化，没有则更新。依赖硬件实现，JVM 封装汇编调用。

AtomicInteger 不需要加锁就可以在多线程并发场景下实现数据一致性。

```java
public class Test{
  private AtomicInteger i = new AtomicInteger(0);
  public int add(){
    return i.addAndGet(1);
  }
}
```

##### ABA 问题

> 追加版本号

##### 循环时间长开销大

> CAS 长时间不成功，会给 CPU 带来非常大的执行开销。

##### 只能保证一个共享变量的原子操作

> 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。



## UnSafe 类详解

> sun.misc 包下的一个类，提供一些低级别、不安全的方法，如直接访问内存资源、管理系统资源等。

![java-thread-x-atomicinteger-unsafe](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-atomicinteger-unsafe.png)

### Unsafe 提供 CAS 实现

```java
public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);

public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);

public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3);
```

### 

### AtomicInteger

常用 API：

```java
public final int get()：获取当前的值
public final int getAndSet(int newValue)：获取当前的值，并设置新的值
public final int getAndIncrement()：获取当前的值，并自增
public final int getAndDecrement()：获取当前的值，并自减
public final int getAndAdd(int delta)：获取当前的值，并加上预期的值
void lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

##### 优势：

多线程可以直接执行自增，保证线程安全。

##### 底层实现：

volatile 和 CAS 来实现更改数据。volatile 保证可见性，CAS 保证数据更新原子性。

### 延伸：

##### 原子更新基本类型：

- AtomicBoolean: 原子更新布尔类型。
- AtomicInteger: 原子更新整型。
- AtomicLong: 原子更新长整型。

##### 原子更新数组：

* AtomicIntegerArray: 原子更新整型数组里的元素。

* AtomicLongArray: 原子更新长整型数组里的元素。

* AtomicReferenceArray: 原子更新引用类型数组里的元素。  这三个类的最常用的方法是如下两个方法：

* get(int index)：获取索引为index的元素值。

* compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。

```java
public class Demo5 {
    public static void main(String[] args) throws InterruptedException {
        AtomicIntegerArray array = new AtomicIntegerArray(new int[] { 0, 0 });
        System.out.println(array);
        System.out.println(array.getAndAdd(1, 2));
        System.out.println(array);
    }
}

```

##### 原子更新引用类：

* AtomicReference: 原子更新引用类型。

* AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。

* AtomicMarkableReferce: 原子更新带有标记位的引用类型。

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceTest {
    
    public static void main(String[] args){

        // 创建两个Person对象，它们的id分别是101和102。
        Person p1 = new Person(101);
        Person p2 = new Person(102);
        // 新建AtomicReference对象，初始化它的值为p1对象
        AtomicReference ar = new AtomicReference(p1);
        // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。
        ar.compareAndSet(p1, p2);

        Person p3 = (Person)ar.get();
        System.out.println("p3 is "+p3);
        System.out.println("p3.equals(p1)="+p3.equals(p1));
    }
}

class Person {
    volatile long id;
    public Person(long id) {
        this.id = id;
    }
    public String toString() {
        return "id:"+id;
    }
}

```

##### 原子更新字段类：

* AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。

* AtomicLongFieldUpdater: 原子更新长整型字段的更新器。

* AtomicStampedFieldUpdater: 原子更新带有版本号的引用类型。

* AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。

```java
public class TestAtomicIntegerFieldUpdater {

    public static void main(String[] args){
        TestAtomicIntegerFieldUpdater tIA = new TestAtomicIntegerFieldUpdater();
        tIA.doIt();
    }

    public AtomicIntegerFieldUpdater<DataDemo> updater(String name){
        return AtomicIntegerFieldUpdater.newUpdater(DataDemo.class,name);

    }

    public void doIt(){
        DataDemo data = new DataDemo();
        System.out.println("publicVar = "+updater("publicVar").getAndAdd(data, 2));
        /*
            * 由于在DataDemo类中属性value2/value3,在TestAtomicIntegerFieldUpdater中不能访问
            * */
        //System.out.println("protectedVar = "+updater("protectedVar").getAndAdd(data,2));
        //System.out.println("privateVar = "+updater("privateVar").getAndAdd(data,2));

        //System.out.println("staticVar = "+updater("staticVar").getAndIncrement(data));//报java.lang.IllegalArgumentException
        /*
            * 下面报异常：must be integer
            * */
        //System.out.println("integerVar = "+updater("integerVar").getAndIncrement(data));
        //System.out.println("longVar = "+updater("longVar").getAndIncrement(data));
    }

}

class DataDemo{
    public volatile int publicVar=3;
    protected volatile int protectedVar=4;
    private volatile  int privateVar=5;

    public volatile static int staticVar = 10;
    //public  final int finalVar = 11;

    public volatile Integer integerVar = 19;
    public volatile Long longVar = 18L;

}

```



# 8 - LockSupport 详解

> LockSupport 是 AQS 的两个核心使用类之一，提供 park() unpark() 操作。

* park()，阻塞线程。
* unpark()，释放线程许可。（函数是不安全的，调用这个函数要保证线程依旧存活）

**park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。**

### park 函数

```java
public static void park()；
public static void park(Object blocker)；
```

```java
public static void park(Object blocker) {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 设置Blocker
    setBlocker(t, blocker);
    // 获取许可,阻塞
    UNSAFE.park(false, 0L);
    // 重新可运行后再此设置Blocker 为 null
    setBlocker(t, null);
}
```

### parkNanos 函数

```java
public static void parkNanos(Object blocker, long nanos) {
    if (nanos > 0) { // 时间大于0
        // 获取当前线程
        Thread t = Thread.currentThread();
        // 设置Blocker
        setBlocker(t, blocker);
        // 获取许可，并设置了时间
        UNSAFE.park(false, nanos);
        // 设置许可
        setBlocker(t, null);
    }
}
```

此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。

### parkUntil函数

```java
public static void parkUntil(Object blocker, long deadline) {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 设置Blocker
    setBlocker(t, blocker);
    UNSAFE.park(true, deadline);
    // 设置Blocker为null
    setBlocker(t, null);
}
```

### unpark函数

```java
public static void unpark(Thread thread) {
    if (thread != null) // 线程为不空
        UNSAFE.unpark(thread); // 释放该线程许可
}
```

### thread.Interrupte() 跟 unpark() 起到一样的作用



## 更深入的理解

### Thread.sleep() 和 Object.wait() 的区别

本质区别：sleep() 不会释放资源，wait() 会释放资源。

* sleep() 不会释放锁，wait() 会释放锁。
* sleep() 必须传入时间，wait() 不用。
* sleep() 到时间自动唤醒，wait() 不带时间的需要 notify() 唤醒。
* wait() 带时间的自动唤醒分为两种情况，一是立刻获取锁执行；二是进入同步队列等待获取锁。



### Object.wait() 和 Condition.await() 的区别

它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。

原理基本一致，不同的是 Condition.await() 底层是调用 LockSupport.park() 来实现阻塞当前线程。



### Thread.sleep()和LockSupport.park()的区别

从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；

* Thread.sleep()没法从外部唤醒，只能自己醒过来；

* LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；

* Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；

* LockSupport.park()方法不需要捕获中断异常；

* Thread.sleep()本身就是一个native方法；

* LockSupport.park()底层是调用的Unsafe的native方法；



### Object.wait()和LockSupport.park()的区别

* Object.wait()方法需要在synchronized块中执行；

* LockSupport.park()可以在任意地方执行；

* Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；

* LockSupport.park()不需要捕获中断异常；

* Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；

* LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；



# AQS

> AbstractQueuedSynchronizer 是一个构建锁和同步器的框架。
>
> 例如：ReentrantLock、Semaphore、ReentrantReadWriteLock、SynchronousQueue、FeatureTask 等。



###  AQS 核心思想

**锁定共享资源，将请求线程设置为有效工作线程（当共享资源空闲）。**

**CLH 队列锁，实现线程阻塞等待及唤醒锁分配机制，每个请求线程封装成一个结点。**

> CLH 队列：虚拟的双向队列（仅存在节点间的关联关系），AQS 将每个请求线程封装成一个结点来实现锁分配。

![QIKsHg](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/QIKsHg.png)

```java
private volatile int state;//共享变量，使用volatile修饰保证线程可见性

//返回同步状态的当前值
protected final int getState() {  
        return state;
}
 // 设置同步状态的值
protected final void setState(int newState) { 
        state = newState;
}
//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)
protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```



### AQS 对资源的共享方式

* Exclusive（独占）：只有一个线程能运行
  * 公平锁
  * 非公平锁

* Share（共享）：多个线程可以同时执行。

  > 如 Semaphore/CountDownLatch。

ReentrantReadWriteLock 是组合式，读是共享，写是独占。



### AQS 底层使用模板方法

> 继承 AbstractQueuedSynchronizer 并重写指定方法（对于共享资源 state 的获取和释放）。

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```



### AQS 数据结构

虚拟的双向队列。

![java-thread-x-juc-aqs-1](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-aqs-1.png)

### AQS 源码分析

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable
```

#### 父类：AbstractOwnableSynchronizer

```java
public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
    
    // 版本序列号
    private static final long serialVersionUID = 3737899427754241961L;
    // 构造方法
    protected AbstractOwnableSynchronizer() { }
    // 独占模式下的线程
    private transient Thread exclusiveOwnerThread;
    
    // 设置独占线程 
    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }
    
    // 获取独占线程 
    protected final Thread getExclusiveOwnerThread() {
        return exclusiveOwnerThread;
    }
}
```

#### 内部类：Node

```java
static final class Node {
    // 模式，分为共享与独占
    // 共享模式
    static final Node SHARED = new Node();
    // 独占模式
    static final Node EXCLUSIVE = null;        
    // 节点状态
    static final int CANCELLED =  1;
    static final int SIGNAL    = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;        

    // 结点状态
    volatile int waitStatus;        
    // 前驱结点
    volatile Node prev;    
    // 后继结点
    volatile Node next;        
    // 结点所对应的线程
    volatile Thread thread;        
    // 下一个等待者
    Node nextWaiter;
    
    // 结点是否在共享模式下等待
    final boolean isShared() {
        return nextWaiter == SHARED;
    }
    
    // 获取前驱结点，若前驱结点为空，抛出异常
    final Node predecessor() throws NullPointerException {
        // 保存前驱结点
        Node p = prev; 
        if (p == null) // 前驱结点为空，抛出异常
            throw new NullPointerException();
        else // 前驱结点不为空，返回
            return p;
    }
    
    // 无参构造方法
    Node() {    // Used to establish initial head or SHARED marker
    }
    
    // 构造方法
        Node(Thread thread, Node mode) {    // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }
    
    // 构造方法
    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
```

##### 结点状态：

*  **CANCELLED**，值为1，表示当前的线程被取消
* **SIGNAL**，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark
*  **CONDITION**，值为-2，表示当前节点在等待condition，也就是在condition队列中
*  **PROPAGATE**，值为-3，表示当前场景下后续的acquireShared能够得以执行
*  值为0，表示当前节点在sync队列中，等待着获取锁



#### 内部类：ConditionObject

```java
public interface Condition {

    // 等待，当前线程在接到信号或被中断之前一直处于等待状态
    void await() throws InterruptedException;
    
    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断
    void awaitUninterruptibly();
    
    //等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    
    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) > 0
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    
    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态
    boolean awaitUntil(Date deadline) throws InterruptedException;
    
    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。
    void signal();
    
    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。
    void signalAll();
}
```

```java
// 内部类
public class ConditionObject implements Condition, java.io.Serializable {
    // 版本号
    private static final long serialVersionUID = 1173984872572414699L;
    // condition队列的头节点
    private transient Node firstWaiter;
    // condition队列的尾结点
    private transient Node lastWaiter;

    // 构造方法
    public ConditionObject() { }

    // 添加新的waiter到wait队列
    private Node addConditionWaiter() {
        // 保存尾结点
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        if (t != null && t.waitStatus != Node.CONDITION) { // 尾结点不为空，并且尾结点的状态不为CONDITION
            // 清除状态为CONDITION的结点
            unlinkCancelledWaiters(); 
            // 将最后一个结点重新赋值给t
            t = lastWaiter;
        }
        // 新建一个结点
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null) // 尾结点为空
            // 设置condition队列的头节点
            firstWaiter = node;
        else // 尾结点不为空
            // 设置为节点的nextWaiter域为node结点
            t.nextWaiter = node;
        // 更新condition队列的尾结点
        lastWaiter = node;
        return node;
    }

    /**
        * Removes and transfers nodes until hit non-cancelled one or
        * null. Split out from signal in part to encourage compilers
        * to inline the case of no waiters.
        * @param first (non-null) the first node on condition queue
        */
    private void doSignal(Node first) {
        // 循环
        do {
            if ( (firstWaiter = first.nextWaiter) == null) // 该节点的nextWaiter为空
                // 设置尾结点为空
                lastWaiter = null;
            // 设置first结点的nextWaiter域
            first.nextWaiter = null;
        } while (!transferForSignal(first) &&
                    (first = firstWaiter) != null); // 将结点从condition队列转移到sync队列失败并且condition队列中的头节点不为空，一直循环
    }

    /**
        * Removes and transfers all nodes.
        * @param first (non-null) the first node on condition queue
        */
    private void doSignalAll(Node first) {
        // condition队列的头节点尾结点都设置为空
        lastWaiter = firstWaiter = null;
        // 循环
        do {
            // 获取first结点的nextWaiter域结点
            Node next = first.nextWaiter;
            // 设置first结点的nextWaiter域为空
            first.nextWaiter = null;
            // 将first结点从condition队列转移到sync队列
            transferForSignal(first);
            // 重新设置first
            first = next;
        } while (first != null);
    }

    // 从condition队列中清除状态为CANCEL的结点
    private void unlinkCancelledWaiters() {
        // 保存condition队列头节点
        Node t = firstWaiter;
        Node trail = null;
        while (t != null) { // t不为空
            // 下一个结点
            Node next = t.nextWaiter;
            if (t.waitStatus != Node.CONDITION) { // t结点的状态不为CONDTION状态
                // 设置t节点的nextWaiter域为空
                t.nextWaiter = null;
                if (trail == null) // trail为空
                    // 重新设置condition队列的头节点
                    firstWaiter = next;
                else // trail不为空
                    // 设置trail结点的nextWaiter域为next结点
                    trail.nextWaiter = next;
                if (next == null) // next结点为空
                    // 设置condition队列的尾结点
                    lastWaiter = trail;
            }
            else // t结点的状态为CONDTION状态
                // 设置trail结点
                trail = t;
            // 设置t结点
            t = next;
        }
    }

    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。
    public final void signal() {
        if (!isHeldExclusively()) // 不被当前线程独占，抛出异常
            throw new IllegalMonitorStateException();
        // 保存condition队列头节点
        Node first = firstWaiter;
        if (first != null) // 头节点不为空
            // 唤醒一个等待线程
            doSignal(first);
    }

    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。
    public final void signalAll() {
        if (!isHeldExclusively()) // 不被当前线程独占，抛出异常
            throw new IllegalMonitorStateException();
        // 保存condition队列头节点
        Node first = firstWaiter;
        if (first != null) // 头节点不为空
            // 唤醒所有等待线程
            doSignalAll(first);
    }

    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断
    public final void awaitUninterruptibly() {
        // 添加一个结点到等待队列
        Node node = addConditionWaiter();
        // 获取释放的状态
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        while (!isOnSyncQueue(node)) { // 
            // 阻塞当前线程
            LockSupport.park(this);
            if (Thread.interrupted()) // 当前线程被中断
                // 设置interrupted状态
                interrupted = true; 
        }
        if (acquireQueued(node, savedState) || interrupted) // 
            selfInterrupt();
    }

    /*
        * For interruptible waits, we need to track whether to throw
        * InterruptedException, if interrupted while blocked on
        * condition, versus reinterrupt current thread, if
        * interrupted while blocked waiting to re-acquire.
        */

    /** Mode meaning to reinterrupt on exit from wait */
    private static final int REINTERRUPT =  1;
    /** Mode meaning to throw InterruptedException on exit from wait */
    private static final int THROW_IE    = -1;

    /**
        * Checks for interrupt, returning THROW_IE if interrupted
        * before signalled, REINTERRUPT if after signalled, or
        * 0 if not interrupted.
        */
    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0; 
    }

    /**
        * Throws InterruptedException, reinterrupts current thread, or
        * does nothing, depending on mode.
        */
    private void reportInterruptAfterWait(int interruptMode)
        throws InterruptedException {
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }

    // // 等待，当前线程在接到信号或被中断之前一直处于等待状态
    public final void await() throws InterruptedException {
        if (Thread.interrupted()) // 当前线程被中断，抛出异常
            throw new InterruptedException();
        // 在wait队列上添加一个结点
        Node node = addConditionWaiter();
        // 
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            // 阻塞当前线程
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) // 检查结点等待时的中断类型
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }

    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 
    public final long awaitNanos(long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    }

    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态
    public final boolean awaitUntil(Date deadline)
            throws InterruptedException {
        long abstime = deadline.getTime();
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (System.currentTimeMillis() > abstime) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            LockSupport.parkUntil(this, abstime);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }

    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) > 0
    public final boolean await(long time, TimeUnit unit)
            throws InterruptedException {
        long nanosTimeout = unit.toNanos(time);
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }

    //  support for instrumentation

    final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
        return sync == AbstractQueuedSynchronizer.this;
    }

    //  查询是否有正在等待此条件的任何线程
    protected final boolean hasWaiters() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                return true;
        }
        return false;
    }

    // 返回正在等待此条件的线程数估计值
    protected final int getWaitQueueLength() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int n = 0;
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                ++n;
        }
        return n;
    }

    // 返回包含那些可能正在等待此条件的线程集合
    protected final Collection<Thread> getWaitingThreads() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION) {
                Thread t = w.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }
}

```

#### AQS 类型属性

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer
    implements java.io.Serializable {    
    // 版本号
    private static final long serialVersionUID = 7373984972572414691L;    
    // 头节点
    private transient volatile Node head;    
    // 尾结点
    private transient volatile Node tail;    
    // 状态
    private volatile int state;    
    // 自旋时间
    static final long spinForTimeoutThreshold = 1000L;
    
    // Unsafe类实例
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    // state内存偏移地址
    private static final long stateOffset;
    // head内存偏移地址
    private static final long headOffset;
    // tail内存偏移地址
    private static final long tailOffset;
    // waitStatus内存偏移地址
    private static final long waitStatusOffset;
    // next内存偏移地址
    private static final long nextOffset;
    // 静态初始化块
    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("state"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("head"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("tail"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("waitStatus"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("next"));

        } catch (Exception ex) { throw new Error(ex); }
    }
}
```

#### AQS 核心方法 - acquire()

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

![java-thread-x-juc-aqs-2](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-aqs-2.png)

1. 首先调用tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。

2. 若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。

3. 调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。

4. 由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。

##### addWaiter() 方法：

```java
// 添加等待者
private Node addWaiter(Node mode) {
    // 新生成一个结点，默认为独占模式
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    // 保存尾结点
    Node pred = tail;
    if (pred != null) { // 尾结点不为空，即已经被初始化
        // 将node结点的prev域连接到尾结点
        node.prev = pred; 
        if (compareAndSetTail(pred, node)) { // 比较pred是否为尾结点，是则将尾结点设置为node 
            // 设置尾结点的next域为node
            pred.next = node;
            return node; // 返回新生成的结点
        }
    }
    enq(node); // 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列
    return node;
}
```

##### sync queue 未初始化，enqueue() 方法：

```java
private Node enq(final Node node) {
    for (;;) { // 无限循环，确保结点能够成功入队列
        // 保存尾结点
        Node t = tail;
        if (t == null) { // 尾结点为空，即还没被初始化
            if (compareAndSetHead(new Node())) // 头节点为空，并设置头节点为新生成的结点
                tail = head; // 头节点与尾结点都指向同一个新生结点
        } else { // 尾结点不为空，即已经被初始化过
            // 将node结点的prev域连接到尾结点
            node.prev = t; 
            if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node
                // 设置尾结点的next域为node
                t.next = node; 
                return t; // 返回尾结点
            }
        }
    }
}
```

##### acquireQueued() 方法：

```java
// sync队列中的结点在独占且忽略中断的模式下获取(资源)
final boolean acquireQueued(final Node node, int arg) {
    // 标志
    boolean failed = true;
    try {
        // 中断标志
        boolean interrupted = false;
        for (;;) { // 无限循环
            // 获取node节点的前驱结点
            final Node p = node.predecessor(); 
            if (p == head && tryAcquire(arg)) { // 前驱为头节点并且成功获得锁
                setHead(node); // 设置头节点
                p.next = null; // help GC
                failed = false; // 设置标志
                return interrupted; 
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

首先获取当前节点的前驱节点，如果前驱节点是头节点并且能够获取(资源)，代表该当前节点能够占有锁，设置头节点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法，首先，我们看shouldParkAfterFailedAcquire方法，代码如下:

```java
// 当获取(资源)失败后，检查并且更新结点状态
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    // 获取前驱结点的状态
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) // 状态为SIGNAL，为-1
        /*
            * This node has already set status asking a release
            * to signal it, so it can safely park.
            */
        // 可以进行park操作
        return true; 
    if (ws > 0) { // 表示状态为CANCELLED，为1
        /*
            * Predecessor was cancelled. Skip over predecessors and
            * indicate retry.
            */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0); // 找到pred结点前面最近的一个状态不为CANCELLED的结点
        // 赋值pred结点的next域
        pred.next = node; 
    } else { // 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) 
        /*
            * waitStatus must be 0 or PROPAGATE.  Indicate that we
            * need a signal, but don't park yet.  Caller will need to
            * retry to make sure it cannot acquire before parking.
            */
        // 比较并设置前驱结点的状态为SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); 
    }
    // 不能进行park操作
    return false;
}
```

只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt方法，源码如下:

```java
// 进行park操作并且返回该线程是否被中断
private final boolean parkAndCheckInterrupt() {
    // 在许可可用之前禁用当前线程，并且设置了blocker
    LockSupport.park(this);
    return Thread.interrupted(); // 当前线程是否已被中断，并清除中断标记位
}
```

##### cancelAcquire() 方法：

```java
// 取消继续获取(资源)
private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    // node为空，返回
    if (node == null)
        return;
    // 设置node结点的thread为空
    node.thread = null;

    // Skip cancelled predecessors
    // 保存node的前驱结点
    Node pred = node.prev;
    while (pred.waitStatus > 0) // 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    // 获取pred结点的下一个结点
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    // 设置node结点的状态为CANCELLED
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail && compareAndSetTail(node, pred)) { // node结点为尾结点，则设置尾结点为pred结点
        // 比较并设置pred结点的next节点为null
        compareAndSetNext(pred, predNext, null); 
    } else { // node结点不为尾结点，或者比较设置不成功
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &&
            ((ws = pred.waitStatus) == Node.SIGNAL ||
                (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
            pred.thread != null) { // (pred结点不为头节点，并且pred结点的状态为SIGNAL)或者 
                                // pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空
            // 保存结点的后继
            Node next = node.next;
            if (next != null && next.waitStatus <= 0) // 后继不为空并且后继的状态小于等于0
                compareAndSetNext(pred, predNext, next); // 比较并设置pred.next = next;
        } else {
            unparkSuccessor(node); // 释放node的前一个结点
        }

        node.next = node; // help GC
    }
}
```

该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor方法，该方法的作用就是为了释放node节点的后继结点。源码如下:

```java
// 释放后继结点
private void unparkSuccessor(Node node) {
    /*
        * If status is negative (i.e., possibly needing signal) try
        * to clear in anticipation of signalling.  It is OK if this
        * fails or if status is changed by waiting thread.
        */
    // 获取node结点的等待状态
    int ws = node.waitStatus;
    if (ws < 0) // 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3
        // 比较并且设置结点等待状态，设置为0
        compareAndSetWaitStatus(node, ws, 0);

    /*
        * Thread to unpark is held in successor, which is normally
        * just the next node.  But if cancelled or apparently null,
        * traverse backwards from tail to find the actual
        * non-cancelled successor.
        */
    // 获取node节点的下一个结点
    Node s = node.next;
    if (s == null || s.waitStatus > 0) { // 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED
        // s赋值为空
        s = null; 
        // 从尾结点开始从后往前开始遍历
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0) // 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点
                // 保存结点
                s = t;
    }
    if (s != null) // 该结点不为为空，释放许可
        LockSupport.unpark(s.thread);
}
```

![java-thread-x-juc-aqs-3](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-aqs-3.png)



#### 类的核心方法 - release()

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) { // 释放成功
        // 保存头节点
        Node h = head; 
        if (h != null && h.waitStatus != 0) // 头节点不为空并且头节点状态不为0
            unparkSuccessor(h); //释放头节点的后继结点
        return true;
    }
    return false;
}
```



# ReentrantLock 详解

> 可重入锁 ReentrantLock 底层是通过 AQS 实现的。

## ReentrantLock 源码分析

```java
public class ReentrantLock implements Lock, java.io.Serializable
```

### 内部类

![java-thread-x-juc-reentrantlock-1](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-reentrantlock-1.png)

#### Sync 类

Sync 类继承 AQS

![java-thread-x-juc-reentrantlock-2](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-reentrantlock-2.png)

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 序列号
    private static final long serialVersionUID = -5179523762034025860L;
    
    // 获取锁
    abstract void lock();
    
    // 非公平方式获取
    final boolean nonfairTryAcquire(int acquires) {
        // 当前线程
        final Thread current = Thread.currentThread();
        // 获取状态
        int c = getState();
        if (c == 0) { // 表示没有线程正在竞争该锁
            if (compareAndSetState(0, acquires)) { // 比较并设置状态成功，状态0表示锁没有被占用
                // 设置当前线程独占
                setExclusiveOwnerThread(current); 
                return true; // 成功
            }
        }
        else if (current == getExclusiveOwnerThread()) { // 当前线程拥有该锁
            int nextc = c + acquires; // 增加重入次数
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            // 设置状态
            setState(nextc); 
            // 成功
            return true; 
        }
        // 失败
        return false;
    }
    
    // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread()) // 当前线程不为独占线程
            throw new IllegalMonitorStateException(); // 抛出异常
        // 释放标识
        boolean free = false; 
        if (c == 0) {
            free = true;
            // 已经释放，清空独占
            setExclusiveOwnerThread(null); 
        }
        // 设置标识
        setState(c); 
        return free; 
    }
    
    // 判断资源是否被当前线程占有
    protected final boolean isHeldExclusively() {
        // While we must in general read state before owner,
        // we don't need to do so to check if current thread is owner
        return getExclusiveOwnerThread() == Thread.currentThread();
    }

    // 新生一个条件
    final ConditionObject newCondition() {
        return new ConditionObject();
    }

    // Methods relayed from outer class
    // 返回资源的占用线程
    final Thread getOwner() {        
        return getState() == 0 ? null : getExclusiveOwnerThread();
    }
    // 返回状态
    final int getHoldCount() {            
        return isHeldExclusively() ? getState() : 0;
    }

    // 资源是否被占用
    final boolean isLocked() {        
        return getState() != 0;
    }

    /**
        * Reconstitutes the instance from a stream (that is, deserializes it).
        */
    // 自定义反序列化逻辑
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        setState(0); // reset to unlocked state
    }
}　　
```

#### NonfairSync 类

```java
// 非公平锁
static final class NonfairSync extends Sync {
    // 版本号
    private static final long serialVersionUID = 7316153563782823691L;

    // 获得锁
    final void lock() {
        if (compareAndSetState(0, 1)) // 比较并设置状态成功，状态0表示锁没有被占用
            // 把当前线程设置独占了锁
            setExclusiveOwnerThread(Thread.currentThread());
        else // 锁已经被占用，或者set失败
            // 以独占模式获取对象，忽略中断
            acquire(1); 
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
```

#### FairSync 类

判断是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部。

```java
// 公平锁
static final class FairSync extends Sync {
    // 版本序列化
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        // 以独占模式获取对象，忽略中断
        acquire(1);
    }

    /**
        * Fair version of tryAcquire.  Don't grant access unless
        * recursive call or no waiters or is first.
        */
    // 尝试公平获取锁
    protected final boolean tryAcquire(int acquires) {
        // 获取当前线程
        final Thread current = Thread.currentThread();
        // 获取状态
        int c = getState();
        if (c == 0) { // 状态为0
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) { // 不存在已经等待更久的线程并且比较并且设置状态成功
                // 设置当前线程独占
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) { // 状态不为0，即资源已经被线程占据
            // 下一个状态
            int nextc = c + acquires;
            if (nextc < 0) // 超过了int的表示范围
                throw new Error("Maximum lock count exceeded");
            // 设置状态
            setState(nextc);
            return true;
        }
        return false;
    }
}
```

![java-thread-x-juc-reentrantlock-3](http://blog-shifty.oss-cn-shanghai.aliyuncs.com/uPic/java-thread-x-juc-reentrantlock-3.png)

**可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和Nonfair最大的区别，Nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。**



### 类属性

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    // 序列号
    private static final long serialVersionUID = 7373984872572414699L;    
    // 同步队列
    private final Sync sync;
}
```

大部分功能都是转换成对 Sync 和 AQS 类的操作。



### 类构造函数

默认非公平锁

```java
public ReentrantLock() {
    // 默认非公平策略
    sync = new NonfairSync();
}
```

可选参数

```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```





















